(* Simple DPLL *)

use int.Int
(**
	* -nlit ... nlit
	* +i means x_i
	* -i means Â¬x_i
	* 0 is not a literal
	*)
type literal = int

use list.List
type clause = list literal

use list.Length
use bool.Bool

(* Subst {{{ *)
use list.Mem
use list.Quant as Q
use filter.Filter
use mapHigher.Map
(**
	* we replace `x` by the truth value `b`
	* in other words, simplify the entire formula thanks to the replacement of the literal
	*)
let function subst (lit : literal) (clauses : list clause) : list clause
	ensures {
		forall cls:clause. mem cls result ->
		(forall l. mem l cls -> l <> lit /\ l <> (-lit))
	}
=
	let trivial_clauses_removed = filter (fun c -> not (Q.mem (=) lit c)) clauses in
	assert { forall c. mem c trivial_clauses_removed -> not (mem lit c) };
  
	let neg_lit_removed = map (filter (fun v -> v <> (-lit))) trivial_clauses_removed in
	assert { forall c. mem c neg_lit_removed -> not (mem lit c) };
	assert { forall c. mem c neg_lit_removed -> forall l. mem l c -> l <> (-lit) };

	neg_lit_removed
(* }}} *)
(* Variant : Clauses length {{{ *)
let rec function formula_length (clauses: list clause) : int
	ensures {result >= 0}
=
	match clauses with
	| Nil -> 0
	| Cons cls clauses -> length cls + formula_length clauses
	end

lemma Subst_decreases_formula_length:
	forall clauses : list clause. forall lit.
	Q.for_some (fun clause -> mem lit clause) clauses
		-> formula_length (subst lit clauses) < formula_length clauses
(* }}} *)

type assignment = list literal

use int.Abs
let rec predicate valid (assign : assignment) (nlit : int) =
	requires { nlit>=0 }
	match assign with
	| Nil -> true
	| Cons lit tl ->
		andb (abs lit <= nlit)
		(andb
			(not (Q.mem (=) (-lit) tl))
			(valid tl nlit))
	end

let rec function clause_eq (c1 c2 : clause) : bool
	ensures {result <-> c1 = c2}
=
	match c1,c2 with
	| Nil,Nil -> true
	| Cons x c1, Cons y c2 -> andb (x = y) (clause_eq c1 c2)
	| _ -> false
	end

let rec predicate sat (assign : assignment) (clauses : list clause) =
	match assign with
	| Nil -> not (Q.mem clause_eq Nil clauses)
	| Cons lit assign -> sat assign (subst lit clauses)
	end

use option.Option
let rec dpll (clauses : list clause) (nlit : int) : option assignment
	ensures {
		match result with
		| None -> true
		| Some assign -> valid assign nlit
		end}
	ensures {
		match result with
		| None -> (forall assign. valid assign nlit -> not (sat assign clauses))
		| Some assign -> sat assign clauses
		end }
	variant { formula_length clauses }
=
	match clauses with
	| Nil -> Some Nil
	| Cons cls _ -> (
		match cls with
		| Nil -> None
		| Cons lit _ -> (
			match dpll (subst lit clauses) nlit with
			| Some assign -> Some (Cons lit assign)
			| None -> (
				match dpll (subst (-lit) clauses) nlit with
				| Some assign -> Some (Cons (-lit) assign)
				| None -> None
				end)
			end)
		end)
	end

(* vim: set foldmethod=marker : *)
