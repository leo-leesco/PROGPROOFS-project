(* Simple DPLL *)

use int.Int

(**
	* -nvar ... nvar
	* +i means x_i
	* -i means Â¬x_i
	* 0 is not a literal
	*)
type literal = int

use list.SortedInt
use list.Zip
use list.Quant

(** we limit length clause <= 3 *)
type clause = list literal
let rec clause_eq (l m : list literal) : bool
	requires { sorted l }
	requires { sorted m }
	ensures { result <-> l = m }
=
	match l, m with
	| Cons x l, Cons y m -> x = y /\ clause_eq l m
	| Nil, Nil -> true
	| _, _ -> false
	end

	
use filter.Filter
clone filter.Filter as clause_filter with
	type t = clause
	val (~=) = clause_eq

type cnf = list clause

use list.Map

(**
	* we replace `x` by the truth value `b`
	* in other words, simplify the entire cnf thanks to the replacement of the literal
	*)
let subst x b clauses =
	let trivially_verified_clauses_removed = filter (fun c -> not (mem (b, x) c)) clauses in
  map (filter (fun v -> not (v = (not b, x)))) (* in each clause, if there `x` is found, with the negative positivity (because of the result of filtering, every occurence of `x` in the clause is necessarily of opposite positivity) *)

let rec dpll clauses =
  match clauses with
  | Nil -> true
  | Cons c1 _ -> (
      match c1 with
      | Nil -> false
      | Cons (_, head) _ ->
          dpll (subst head true clauses)
          || dpll (subst head false clauses))
	end
