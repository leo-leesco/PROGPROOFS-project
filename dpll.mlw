(* Standard library imports *)

use int.Int
use int.Abs
use array.Array

(* Helper function for clause swapping *)

use array.ArrayPermut

let swap (a:array 'a) (i:int) (j:int) : unit
  requires { 0 <= i < length a /\ 0 <= j < length a }
  writes   { a }
  ensures  { exchange (old a) a i j }
= let v = a[i] in
  a[i] <- a[j];
  a[j] <- v

(* Simple DPLL *)

type literal = int (* 1-len_current .. len_current-1 *)
type clause = (literal, literal, literal)

predicate is_literal (len_current: int) (l: literal) =
  -len_current < l < len_current

predicate is_clause (len_current: int) (c: clause) =
  let l1, l2, l3 = c in
  is_literal len_current l1 /\ is_literal len_current l2 /\ is_literal len_current l3

(* An assignment stores for every Boolean variable `i`
   its "truth value", encoded as an integer, which is
   either equal to `i` or to `-i`. In this encoding,
   a non-negative truth value means that the variable
   is false, and a negative truth value means that the
   variable is true. Consequently, the variable `0` is
   always false. *)
type assignment = array int

predicate is_assignment (current: assignment) (to_assign: int) =
  0 < to_assign <= length current /\ current[0] = 0 /\
  forall i. 0 <= i < to_assign -> abs current[i] = i

(* A literal `l` is true in assignment `current` if and only if
   it has been assigned a truth value (`|l| < to_assign`), and
   `current[abs l]` is different from `l`. If `l` is positive,
   it is true only if `current[l]` is negative, and if `l` is
   negative, it is true only if `current[l]` is positive.
   If `l` is zero, `current[l]` has to be zero, too, and
   therefore `l` can only be false. *)

predicate ok_literal (current: assignment) (to_assign: int) (l: literal) =
  is_literal (length current) l /\ 0 <= abs l < to_assign <= length current /\
  current[abs l] <> l

predicate ok_clause (current: assignment) (to_assign: int) (c: clause) =
  let l1, l2, l3 = c in
  ok_literal current to_assign l1 \/ ok_literal current to_assign l2 \/ ok_literal current to_assign l3

(* Function `scan` moves the clauses which are true in
   assignment `current` outside of the active zone `clauses[0..todo)`,
   and returns the new number of active clases `mc` which
   has to be smaller or equal than `todo`. It also returns
   a boolean flag `b` which is set to `false`, when a false
   clause is discovered (i.e., all three literals have been
   assigned a false truth value), and therefore the current
   assignment `current` cannot possibly be extended to a model. *)
let scan (current: assignment) (clauses: array clause) (len_current to_assign todo: int) : (b: bool, mc: int)
= absurd

(* Function `dpll` checks the current state of the search using `scan`,
   and after that, if the search can be continued, extends the current
   assignment `current`, by giving the first unassigned Boolean variable `to_assign`
   one or the other truth value, as per DPLL procedure. This function
   returns `true` if `current` has been extended to a model, and `false`
   if `current` cannot possibly be extended to a model. *)
let rec dpll (current: assignment) (clauses: array clause) (len_current to_assign todo: int) : (s: bool)
= absurd

(* Function `sat` implements a simple 3SAT solver. If it returns `true`,
   assignment `current` contains a model of the clause set `clauses`. If it returns
   `false`, the clause set `clauses` is unsatisfiable. The clauses in `clauses` can
   be reordered during the search. *)
let sat (current: assignment) (clauses: array clause) : (sat: bool)
  requires { 0 < length current /\ current[0] = 0}
  requires { forall i. 0 <= i < length clauses -> is_clause (length current) clauses[i] }
  ensures  { sat -> is_assignment current (length current) }
  ensures  { sat -> forall i. 0 <= i < length clauses -> ok_clause current (length current) clauses[i] }
  ensures  { not sat -> forall mc. is_assignment mc (length current) ->
    exists i. 0 <= i < length clauses /\ not ok_clause mc (length current) clauses[i] }
  ensures  { permut_all (old clauses) clauses }
= dpll current clauses (length current) 1 (length clauses)
