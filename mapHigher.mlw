module Map
	use list.List
	use list.Map
	use list.Mem
	use filter.Filter

	let rec function map (f: list 'a -> list 'a) (l: list (list 'a)) : list (list 'a)
		ensures { forall y. mem y result -> exists x. mem x l /\ y = f x }
		variant { l }
	=
		match l with
		| Nil      -> Nil
		| Cons x r -> Cons (f x) (map f r)
		end

	let rec lemma map_filter (pred: 'a -> bool) (nested : list (list 'a))
		ensures {
			let res = map (filter pred) nested in
			forall x. (forall sub. mem sub nested -> not (mem x sub)) -> (* if it is not in the result, *)
			(forall sub. mem sub res -> not (mem x sub)) (* it is not in the initial list*)
		}
		variant { nested }
	=
		match nested with
		| Nil -> ()
		| Cons _ tail -> map_filter pred tail (* we only recursively verify the rest since the head is trivially verified *)
		end
end
